/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

// Namespaces for common RSS photo extensions
var NS_WALLPAPERS = "http://www.apple.com/ilife/wallpapers";
var NS_MEDIA      = "http://search.yahoo.com/mrss/";
var NS_PHEED      = "http://www.pheed.com/pheed/";
var NS_PB         = "http://snaplog.com/backend/PhotoBlog.html";

var photos;                   // Array containing photos found in feed
var finishedLoading;          // Flag for whether images are loaded
var loadingAnimationTimer;    // Timer for "Loading..." animation
var controls;                 // User interface controls (Controls.js)
var caption;                  // Caption controller (Controls.js)

var slideshow;                // Slideshow controller (Slideshow.js)

//
// Function: parsePhotocastRSSFeed(photocastDoc)
// Parse a PhotoCast in RSS format, attempting to find the images and start loading them
//
// photocastDoc: XML document in RSS format containing the feed
//
function parsePhotocastRSSFeed(photocastDoc)
{
    photos.length = 0;

    var channel = getFirstElementByTagName(photocastDoc, "channel");    
    if (channel) {
        var items = channel.getElementsByTagName("item");
        for (var i = 0; i < items.length; i++) {
            var thisItem = items[i];
            var title = dashcode.getLocalizedString("Ohne Titel");
            var titleElt = getFirstElementByTagName(thisItem, "title");
            if (titleElt && titleElt.firstChild) {
                title = allData(titleElt);
            }
            var imageUrl = findRSSImageURL(thisItem);
            if (imageUrl) {
                photos.push({ title: title, url: imageUrl });
            }
        }
    }
    else {
        alert("No <channel> element in feed");
    }
}

//
// Function: findRSSImageURL(node)
// Try a few different ways to find an image enclosure.
// This is the main place to customize to support a nonstandard feed.
//
// node: feed fragment that may contain an image link
//
// Returns the URL of the image if one was found.
//
function findRSSImageURL(node)
{
    // Look for an RSS 2.0 enclosure
    var enclosures = node.getElementsByTagName("enclosure");
    if (enclosures && enclosures.length) {
        return enclosures[0].getAttribute("url");
    }

    // Flickr uses Media RSS
    enclosures = node.getElementsByTagNameNS(NS_MEDIA, "content");
    if (enclosures && enclosures.length) {
        var encMedium = enclosures[0].getAttribute("medium");
        var encType = enclosures[0].getAttribute("type");
        if ((encMedium && encMedium == "image") || (encType && encType.substr(0, 5) == "image")) {
            return enclosures[0].getAttribute("url");
        }
    }

    // Gallery uses Pheed and PhotoBlog extensions
    enclosures = node.getElementsByTagNameNS(NS_PHEED, "thumbnail");
    if (enclosures && enclosures.length) {
        return allData(enclosures[0]);
    }

    enclosures = node.getElementsByTagNameNS(NS_PB, "thumb");
    if (enclosures && enclosures.length) {
        return allData(enclosures[0]);
    }

    // Also try the iPhoto 6.0 version
    enclosures = node.getElementsByTagNameNS(NS_WALLPAPERS, "image");
    if (enclosures && enclosures.length) {
        return allData(enclosures[0]);
    }
}

//
// Function: parsePhotocastAtomFeed(atomDoc)
// Parse a PhotoCast in Atom format, attempting to find the images and start loading them
//
// atomDoc: XML document in Atom format containing the feed
//
function parsePhotocastAtomFeed(atomDoc)
{
    photos.length = 0;
    
    var feed = atomDoc.documentElement;

    for (var entry = feed.firstChild; entry != null; entry = entry.nextSibling) {
        if (entry.nodeName == "entry") {
            // Get the title out of the entry
            var title = atomTextToHTML(getFirstElementByTagName(entry, "title"));
            // If we couldn't find a title...
            if (title == null || title.innerHTML == "") {
                title = dashcode.getLocalizedString("Ohne Titel");
            }
            else {
                title = title.innerHTML;
            }
            
            // Grab the images out of the <link> tags.
            for (var link = entry.firstChild; link != null; link = link.nextSibling) {
                if (link.nodeName == "link") {
                    var type = link.getAttribute("type");
                    // It is the image url if it has type "image/*"
                    if (type && (type.indexOf("image") > -1)) {
                        var imageUrl = link.getAttribute("href");
                        photos.push({ title: title, url: imageUrl });
                    }
                }
            }
        }
    }
}


//
// Function: atomTextToHTML(element)
// Extracts the content of an atom text construct as HTML for display
//
// element: an Atom element containing an atomTextConstruct per RFC4287
//
// Returns an HTML div Element node containing the HTML
//
function atomTextToHTML(element)
{
    if (!element) {
        return;
    }

    var html;

    var type = element.getAttribute("type");
    if (type && (type.indexOf("xhtml") > -1)) {
        // The spec says there should be a DIV in the XHTML namespace
        var div = getFirstElementByTagName(element, "div", "http://www.w3.org/1999/xhtml");
        if (div) {
            html = div.cloneNode(true);
        }
    }
    else if (type && (type.indexOf("html") > -1)) {
        // Encoded HTML
        html = document.createElement("div");
        html.innerHTML = allData(element);
    }
    else {
        // Plain text
        html = document.createElement("div");
        var elementText = allData(element);
        elementText = elementText.replace(/^\s+/, "");
        elementText = elementText.replace(/\s+$/, "");
        html.innerText = elementText;
    }

    return html;
}

//
// Function: parseResponse(doc)
// When the feed finishes loading, this function is called examine the
// result and call parsePhotocastRSSFeed() or parsePhotocastAtomFeed() on it.
//
// doc: XML document containing the feed
//
function parseResponse(doc)
{
    // Try to figure out what we got back
    if (doc && doc.documentElement) {
        if (doc.documentElement.nodeName == "rss") {
            // Could be a photocast feed
            parsePhotocastRSSFeed(doc);
        }
        else if (doc.documentElement.nodeName == "feed") {
            parsePhotocastAtomFeed(doc);
        }
        else {
            stopLoadingAnimation();
            setLoadingText(dashcode.getLocalizedString("URL enthÃ¤lt keinen Photocast."));
        }
        
        // Preload images
        if (photos.length > 0) {
            // Start the images loading
            for (var i = 0; i < photos.length; i++) {
                var image = new Image();
                photos[i].image = image;
                image.src = photos[i].url;
            }

            startLoadingUpdate();
        }
        else {
            stopLoadingAnimation();
            setLoadingText(dashcode.getLocalizedString("Keine Fotos gefunden."));
        }
    }
    else {
        stopLoadingAnimation();
        setLoadingText(dashcode.getLocalizedString("Empfangen des Photocasts fehlgeschlagen."));
    }
}

//
// Function: loadPhotosFromFeed(url)
// Starts loading the PhotoCast feed
// parseResponse() will be called when it finishes loading.
//
// url: URL of the PhotoCast feed
//
function loadPhotosFromFeed(url)
{
    var xmlRequest = new XMLHttpRequest();
    xmlRequest.overrideMimeType("text/xml");
    xmlRequest.open("GET", url, true);

    xmlRequest.onreadystatechange = function () {
        if (xmlRequest.readyState == 4) {
            parseResponse(xmlRequest.responseXML);
        }
    };

    xmlRequest.send(null);
}

//
// Function: startLoadingUpdate()
// Starts the background process that monitors whether images are loaded
//
function startLoadingUpdate()
{
    updateLoaded();
}

//
// Function: updateLoaded()
// Checks whether images have completed loading.  If so, stops the progress
// indicator and starts the slideshow.
//
function updateLoaded()
{
    var total = photos.length;
    var loaded = 0;
    for (var i = 0; i < total; i++) {
        var image = photos[i].image;
        if (image != null && image.complete) {
            loaded++;
        }
    }

    setLoadedAmount(100 * loaded/total);

    if (loaded < total) {
        setTimeout(updateLoaded, 250);
    }
    else {
        hideLoadingMessage();
        finishedLoading = true;
        setTimeout(startSlideShow, 250);
    }
}

//
// Function: photoChanged(number)
// Called by the slideshow whenever the photo changes so we can update
// the caption.
//
function photoChanged(number)
{
    setCaption(photos[number].title + " [" + (number + 1) + "/" + photos.length + "]");
}

//
// Function: startSlideShow()
// Enables the slideshow and starts it playing.
//
function startSlideShow()
{
    if (controls) {
        controls.setEnabled(true);
        controls.setPaused(false);
    }
    showInterfaceElements();
    slideshow.start();
}

//
// Function: setLoadingText(message)
// Displays a message in the "Loading" area.
// Used by the loading animation and error messages.
//
// message: text to display
//
function setLoadingText(message)
{
    var loadingElt = document.getElementById("loading");
    if (loadingElt) {
        loadingElt.innerText = message;
    }
}

//
// Function: startLoadingAnimation()
// Starts the "Loading..." animation's timer
//
function startLoadingAnimation()
{
    var dots = 0;
    var animateLoadingDots = function ()
    {
        var loading = dashcode.getLocalizedString("Laden");
        for (var i = 0; i < dots; i++) {
            loading = loading + ".";
        }
        setLoadingText(loading);

        if (++dots > 3) {
            dots = 0;
        }
    };

    loadingAnimationTimer = setInterval(animateLoadingDots, 500);
}

//
// Function: stopLoadingAnimation()
// Stops the "Loading..." animation's timer
//
function stopLoadingAnimation()
{
    if (loadingAnimationTimer != null) {
        clearInterval(loadingAnimationTimer);
        loadingAnimationTimer = null;
    }
}

//
// Function: setCaption(captionText)
// Displays a caption in the caption area
//
// captionText: text of the caption to display
//
function setCaption(captionText)
{
    caption.setCaption(captionText);
}

//
// Function: setLoadedAmount(amount)
// Called while photos are loading with the current percentage loaded.
// Not used in the sample template however you may want to take advantage
// of this function if you are displaying a customized progress indicator.
//
// amount: percentage of photos loaded
//
function setLoadedAmount(amount)
{
    // Put your customized progress indicator here
}

//
// Function: getFirstElementByTagName(node, tagName)
// Returns the first result of getElementsByTagName, or null if none.
//
// node: document node to search
// tagName: tag name to look for
//
function getFirstElementByTagName(node, tagName, namespace)
{
    var elements = node.getElementsByTagName(tagName);
    if (elements.length) {
        if (namespace == null || elements[0].namespaceURI == namespace)
            return elements[0];
    }
    else {
        return null;
    }
}

//
// Function: allData(node)
// Concatenate all the text data of a node's children.
//
// node: DOM element to search for text.
//
// Returns the concatenated text.
//
function allData(node)
{
    var data = "";
    if (node && node.firstChild) {
        node = node.firstChild;
        if (node.data) data += node.data;
        while (node = node.nextSibling) {
            if (node.data) data += node.data;
        }
    }

    return data;
}

//
// Function: hideElement(elementId)
// Turn off display for the given element.
//
// elementId: DOM id of the element to hide.
//
function hideElement(elementId)
{
    var element = document.getElementById(elementId);
    if (element) {
        element.style.display = "none";
    }
}

//
// Function: showElement(elementId)
// Turn on display for the given element.
//
// elementId: DOM id of the element to show.
//
function showElement(elementId)
{
    var element = document.getElementById(elementId);
    if (element) {
        element.style.display = "block";
    }
}

//
// Function hideInterfaceElements()
// Hides the user interface controls while the photos are loading
//
function hideInterfaceElements()
{
    controls.hide();
    caption.hide();
}

//
// Function: showInterfaceElements()
// Enables the user interface controls once the slideshow is ready
//
function showInterfaceElements()
{
    controls.show();
    if (attributes.showTitle != 2) {
        caption.show();
    }
}

//
// Function: showLoadingMessage()
// Turns on the "Loading..." message and starts it animating
//
function showLoadingMessage()
{
    showElement("loading");
    startLoadingAnimation();
}

//
// Function: hideLoadingMessage()
// Stops the "Loading..." message's animation and hides it
//
function hideLoadingMessage()
{
    stopLoadingAnimation();
    hideElement("loading");
}

//
// Function: populateDisplayTimeList(displayTimeValues)
// Fills the popup list on the back of the widget with the available
// slide durations
//
// displayTimeValues: list of durations available
//
function populateDisplayTimeList(displayTimeValues)
{
    var popup = document.getElementById("display-time");
    if (popup != null) {
        while (popup.length) {
            popup.remove(0);
        }

        for (var i = 0; i < displayTimeValues.length; i++) {
            var option = document.createElement("option");
            option.value = displayTimeValues[i].value;
            option.innerText = dashcode.getLocalizedString(displayTimeValues[i].text);
            popup.add(option);
        }
    }
}

//
// Function: populateTransitionList(effects)
// Fills the popup list on the back of the widget with the available
// transitions
//
// effects: list of transitions available
//
function populateTransitionList(effects)
{
    var popup = document.getElementById("transition-list");
    if (popup != null) {
        while (popup.length) {
            popup.remove(0);
        }

        popup.effects = effects;

        for (var i = 0; i < effects.length; i++) {
            var option = document.createElement("option");
            option.innerText = dashcode.getLocalizedString(effects[i].name);
            popup.add(option);
        }
    }
}

//
// Function: setTransition(selectedIndex)
// Set the current transition and populate the directions menu
// based on the what's available for this transition.
//
// selectedIndex: menu index of the transition to choose
//
function setTransition(selectedIndex)
{
    var popup = document.getElementById("transition-list");
    if (popup != null) {
        popup.selectedIndex = selectedIndex;
        var effect = popup.effects[popup.selectedIndex];
        if (effect != null) {
            if (effect.directions == null) {
                hideElement("direction-list");
                hideElement("label-direction");
            }
            else {
                populateDirectionList(effect.directions);
            }
        }
    }
}

//
// Function: setSelectedTransition()
// Called when a new transition is selected from the popup menu
//
function setSelectedTransition()
{
    setTransition(document.getElementById("transition-list").selectedIndex);
    setDirection(0);
    activateSelectedTransition();
}

//
// Function: populateDirectionList(directions)
// Fills the popup list on the back of the widget with the available
// transition directions
//
// directions: list of directions available
//
function populateDirectionList(directions)
{
    var popup = document.getElementById("direction-list");
    if (popup != null) {
        while (popup.length) {
            popup.remove(0);
        }

        popup.directions = directions;

        for (var i = 0; i < directions.length; i++) {
            var option = document.createElement("option");
            option.innerText = dashcode.getLocalizedString(directions[i].name);
            popup.add(option);
        }

        showElement("label-direction");
        showElement("direction-list");
    }
}

//
// Function: setDirection(selectedIndex)
// Set the current direction
//
// selectedIndex: menu index of the direction to choose
//
function setDirection(selectedIndex)
{
    var popup = document.getElementById("direction-list");
    if (popup != null) {
        popup.selectedIndex = selectedIndex;
    }
}

//
// Function: setSelectedDirection()
// Called when a new direction is selected from the popup menu
//
function setSelectedDirection()
{
    setDirection(document.getElementById("direction-list").selectedIndex);
    activateSelectedTransition();
}

//
// Function: activateSelectedTransition()
// Get the currently selected values from the popup menus and pass
// them to the slideshow
//
function activateSelectedTransition()
{
    var transitionPopup = document.getElementById("transition-list");
    var directionPopup = document.getElementById("direction-list");
    if (transitionPopup != null && directionPopup != null) {
        setTransitionIndex(transitionPopup.selectedIndex,
                           directionPopup.selectedIndex);
    }
}

//
// Function: setTransitionIndex(effectId, directionId)
// Sets the slideshow to use the selected effect and direction
//
// effectId: menu index of the transition
// directionId: menu index of the direction
//
function setTransitionIndex(effectId, directionId)
{
    slideshow.setTransitionIndex(effectId, directionId);
}

//
// Function: chooseTransition(effectId, directionId)
// Called when widget starts up to initialize the transition according
// to the values selected in the attributes pane
//
// effectId: menu index of the transition
// directionId: menu index of the direction
//
function chooseTransition(effectId, directionId)
{
    setTransition(effectId);
    setDirection(directionId);
    setTransitionIndex(effectId, directionId);
}

//
// Function: setDisplayTime(time)
// Set the current slide duration
//
// time: slide duration in seconds
//
function setDisplayTime(time)
{
    if (time) {
        slideshow.photoDuration = time * 1000;
    }
    else {
        slideshow.photoDuration = null;
    }

    var displayTime = document.getElementById("display-time");
    if (displayTime != null) {
        displayTime.value = time;
    }

    // show or hide the play button
    if (time < 1) {
        controls.setShowPlayButton(false);
    }
    else {
        controls.setShowPlayButton(true);
    }
}

//
// Function: setSelectedDisplayTime()
// Called when a new slide duration is selected
//
function setSelectedDisplayTime()
{
    var displayTime = document.getElementById("display-time");
    var time = parseFloat(displayTime.value);

    // 0 = never
    // otherwise, minimum is 1 second, maximum 999
    if (time == 0.0) {
        time = 0;
    }
    else if (!(time >= 1.0)) {
        time = 1;
    }
    else if (!(time <= 999.0)) {
        time = 999;
    }

    setDisplayTime(time);
}

//
// Function: sendFeedToiPhoto()
// Called by button on the back to open the feed in iPhoto
//
function sendFeedToiPhoto()
{
    openiPhotoEndHandler = function (command)
    {
        if (command.status != 0) {
            alert("iPhoto open failed with status " + command.status + ": " + command.errorString);
        }
    };

    if (attributes.photocastURL != null && attributes.photocastURL.length > 0) {
        widget.system("/usr/bin/open -a iPhoto " + quoteForShell(attributes.photocastURL), openiPhotoEndHandler);
    }
}

//
// Function: quoteForShell(string)
// Escapes unsafe characters for a widget.system call
//
// string: string to escape
//
// Returns the escaped string.
//
function quoteForShell(string)
{
    return "'" + string.replace(/[\\']/g, "\\$&") + "'";
}

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
    dashcode.setupParts();

    photos = new Array();

    slideshow = new Slideshow(document.getElementById("photobox"), photos, photoChanged);

    controls = CreatePlayPauseControls("controls", "front", clickBack, clickPlay, clickPause, clickNext);
    caption = CreateCaptionControl("caption", "front", (attributes.showTitle == 0));
    hideInterfaceElements();

    populateDisplayTimeList(slideshow.getDisplayTimeValues());
    setDisplayTime(+attributes.displayTime);

    populateTransitionList(slideshow.getAvailableTransitions());
    chooseTransition(+attributes.defaultTransition, +attributes.defaultDirection);

    if (attributes.photocastURL != null && attributes.photocastURL.length > 0) {
        attributes.photocastURL = attributes.photocastURL.replace(/^(?:(?:feed|http):\/\/)?/, 'http://');
        attributes.photocastURL = attributes.photocastURL.replace(/photocast\.mac\.com/, 'web.mac.com');
        showLoadingMessage();
        setLoadedAmount(0);

        setTimeout(function () { loadPhotosFromFeed(attributes.photocastURL); }, 1000);
    }
    else {
        setLoadingText(dashcode.getLocalizedString("Kein Photocast angegeben"));
    }

    document.addEventListener("keypress", keyPressed, true);
}

//
// Function: keyPressed(event)
// Handler for keyboard control of the slideshow
//
// event: onClick event from widget.
//
function keyPressed(event)
{
    switch (event.keyIdentifier) {
        case "U+000020":
            controls.keyClickPlay(event);
            break;
        case "Left":
            controls.keyClickBack(event);
            break;
        case "Right":
            controls.keyClickNext(event);
            break;
        default:
            return;
    }

    event.stopPropagation();
    event.preventDefault();
}

//
// Function: clickBack()
// Called by the back button to show the previous slide
//
function clickBack()
{
    slideshow.goBack();
}

//
// Function: clickNext()
// Called by the next button to show the next slide
//
function clickNext()
{
    slideshow.advance();
}

//
// Function: clickPause()
// Called by the pause button to pause the slideshow
//
function clickPause()
{
    if (finishedLoading) {
        slideshow.pause();
    }
}

//
// Function: clickPlay()
// Called by the play button to start the slideshow
//
function clickPlay()
{
    if (finishedLoading) {
        slideshow.resume();
    }
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
    // Stop any timers to prevent CPU usage
    // Remove any preferences as needed
    // widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    // Pause the slideshow to prevent CPU usage
    slideshow.halt();
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
    // Resume the slideshow
    slideshow.unhalt();
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
    slideshow.halt();

    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToBack");
    }

    front.style.display="none";
    back.style.display="block";

    if (window.widget) {
        setTimeout('widget.performTransition();', 0);
    }
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToFront");
    }

    front.style.display="block";
    back.style.display="none";

    if (window.widget) {
        setTimeout('widget.performTransition();', 0);
    }

    slideshow.unhalt();
}

// Initialize the Dashboard event handlers
if (window.widget) {
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}
