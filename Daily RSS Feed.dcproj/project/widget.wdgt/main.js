/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

var entries;           // Feed contents
var currentEntry;      // Which entry is currently displayed
var lastUpdated = 0;   // Track last refresh time to avoid excessive updates

// Values for feed type in the attributes panel
var DFFeedTypeHTML = 0;
var DFFeedTypeImage = 1;

// Define some namespaces commonly used in feeds
var NS_DC = "http://purl.org/dc/elements/1.1/";
var NS_CONTENT = "http://purl.org/rss/1.0/modules/content/";

//
// Function: refreshFeed()
// Starts loading the feed source.
// processFeedDocument() will be called when it finishes loading.
//
function refreshFeed()
{
    var url = attributes.feedURL;
    if (url && url.length) {
        url = url.replace(/^(feed:\/\/)/, "");
        if (url.substring(0, 7).toLowerCase() != "http://") {
            url = "http://" + url;
        }
    }
    else {
        showError(dashcode.getLocalizedString("Keine Feed-URL verfügbar."));
        return;
    }

    setDateText(dashcode.getLocalizedString("Laden") + "...");

    var xmlRequest = new XMLHttpRequest();
    xmlRequest.overrideMimeType("text/xml");
    xmlRequest.open("GET", url, true);

    xmlRequest.onreadystatechange = function () {
        if (xmlRequest.readyState == 4) {
            processFeedDocument(xmlRequest.responseXML);
        }
    };

    xmlRequest.send(null);
}

//
// Function: processFeedDocument(document)
// When the feed finishes loading, this function is called to parse it and display the results.
//
// doc: XML document containing the feed
//
function processFeedDocument(doc)
{
    clearEntries();

    try {
        // Try to figure out what we got back
        if (doc && doc.documentElement) {
            if (doc.documentElement.nodeName == "feed") {
                // Atom
                parseAtomFeed(doc);
            }
            else {
                // Use the RSS parser
                parseRSSFeed(doc);
            }
        }
        else {
            throw new Error(dashcode.getLocalizedString("Laden eines gültigen Feeds fehlgeschlagen."));
        }

        if (entries && entries.length) {
            showEntryWhenLoaded(entries.length - 1);
            // set lastUpdated to the current time to keep track of the last time a request was posted
            lastUpdated = (new Date).getTime();
        }
        else {
            throw new Error("Feed contains no entries.");
        }
    }
    catch (ex) {
        showError(ex);
    }
}

//
// Function: parseAtomFeed(atom)
// Parse an Atom feed, appending it to the global entries array.
//
// atom: Atom feed as an XML document.
//
function parseAtomFeed(doc)
{
    var feed = getFirstElementByTagName(doc, "feed");
    if (feed) {
        for (var thisItem = feed.firstChild; thisItem != null; thisItem = thisItem.nextSibling) {
            if (thisItem.nodeName == "entry") {
                var title = dashcode.getLocalizedString("Ohne Titel");
                var titleElt = getFirstElementByTagName(thisItem, "title");
                if (titleElt && titleElt.firstChild) {
                    title = allData(titleElt);
                }

                var description;
                var descElt = getFirstElementByTagName(thisItem, "summary");
                if (descElt == null) {
                    descElt = getFirstElementByTagName(thisItem, "content");
                }
                if (descElt && descElt.firstChild) {
                    var contentType = descElt.getAttribute("type");
                    if (contentType && (contentType.indexOf("xhtml") > -1 || contentType.indexOf("xml") > -1)) {
                        var xmlSerializer = new XMLSerializer();
                        description = "";
                        for (var f = 0; f < descElt.childNodes.length; f++) {
                            description += xmlSerializer.serializeToString(descElt.childNodes[f]);
                        }
                    }
                    else {
                        description = allData(descElt);
                    }
                }

                var pubDate;
                var pubDateElt = getFirstElementByTagName(thisItem, "updated");
                if (pubDateElt == null) {
                    pubDateElt = getFirstElementByTagName(thisItem, "issued");
                }
                if (pubDateElt == null) {
                    pubDateElt = getFirstElementByTagName(thisItem, "modified");
                }
                if (pubDateElt == null) {
                    pubDateElt = getFirstElementByTagName(thisItem, "created");
                }
                if (pubDateElt && pubDateElt.firstChild) {
                    var isoDate = allData(pubDateElt);
                    pubDate = parseISODate(isoDate);
                }

                if (+attributes.feedType == DFFeedTypeHTML) {
                    // HTML feed
                    if (description) {
                        entries.unshift({ title: title, description: description, date: pubDate });
                    }
                }
                else if (+attributes.feedType == DFFeedTypeImage) {
                    // Image feed
                    var image = getFirstImage(description);
                    if (image) {
                        entries.unshift({ title: title, image: image, date: pubDate });
                    }
                }
            }
        }
    }
    else {
        throw new Error(dashcode.getLocalizedString("Kein <Feed>-Element im Atom-Feed."));
    }
}

//
// Function: parseRSSFeed(rss)
// Parse an RSS feed, appending its contents to the global entries array.
//
// rss: RSS feed as an XML document.
//
function parseRSSFeed(doc)
{
    var items = doc.getElementsByTagName("item");
    for (var i = 0; i < items.length; i++) {
        var thisItem = items[i];

        var title = dashcode.getLocalizedString("Ohne Titel");
        var titleElt = getFirstElementByTagName(thisItem, "title");
        if (titleElt && titleElt.firstChild) {
            title = allData(titleElt);
        }

        var description;
        var descElt = getFirstElementByTagName(thisItem, "encoded", NS_CONTENT);
        if (!descElt) {
            descElt = getFirstElementByTagName(thisItem, "description");
        }
        if (descElt && descElt.firstChild) {
            description = allData(descElt);
        }

        var pubDate = getFirstElementByTagName(thisItem, "pubDate");
        // If there's a pubDate element, use it
        if (pubDate) {
            pubDate = new Date(Date.parse(allData(pubDate)));
        }
        // If not, maybe they're using the Dublin Core date element
        if (pubDate == null) {
            pubDate = getFirstElementByTagName(thisItem, "date", NS_DC);
            if (pubDate) {
                var isoDate = allData(pubDate);
                pubDate = parseISODate(isoDate);
            }
        }

        if (+attributes.feedType == DFFeedTypeHTML) {
            // HTML feed
            if (description) {
                entries.unshift({ title: title, description: description, date: pubDate });
            }
        }
        else if (+attributes.feedType == DFFeedTypeImage) {
            // Image feed
            var image = getFirstImage(description);
            if (image) {
                entries.unshift({ title: title, image: image, date: pubDate });
            }
        }
    }
}

//
// Function: showEntryWhenLoaded(entryNumber)
// Make sure the images within an entry have finished loading before trying to display it.
// If the images haven't loaded yet, tries again in 250 milliseconds until they are ready.
//
// entryNumber: entry to show once any images have been loaded
//
function showEntryWhenLoaded(entryNumber)
{
    var loading = 0;
    for (i = 0; i < entries.length; i++) {
        if (entries[i].image && !entries[i].image.complete) {
            loading++;
        }
    }

    if (loading) {
        setTimeout(function () { showEntryWhenLoaded(entryNumber) }, 250);
    }
    else {
        showEntry(entryNumber);
    }
}

//
// Function: showEntry(entryNumber)
// Display the given item from the feed.
//
// entryNumber: Number of the item to display.
//
function showEntry(entryNumber)
{
    currentEntry = entryNumber;

    if (entries[entryNumber]) {
        var entry = entries[entryNumber];
        if (entry.description != null) {
            setHTMLContent(entry.title, entry.description, entry.date);
        }
        else if (entry.image != null) {
            setImageContent(entry.title, entry.image, entry.date);
        }

        if (entryNumber > 0) {
            showElement("backButton");
        }
        else {
            hideElement("backButton");
        }

        if (entryNumber < entries.length - 1) {
            showElement("forwardButton");
        }
        else {
            hideElement("forwardButton");
        }
    }
}

//
// Function: showError(errorHTML)
// Display an error message in the content area.
//
// errorHTML: HTML message to display.
//
function showError(errorHTML)
{
    setHTMLContent(dashcode.getLocalizedString("Fehler"), errorHTML);
    setDateText(dashcode.getLocalizedString("Täglicher RSS-Feed"));
    hideElement("forwardButton");
    hideElement("backButton");
}

//
// Function: clearEntries()
// Remove all the stored feed entries.
//
function clearEntries()
{
    entries.length = 0;
}

//
// Function: clearContent()
// Clear the current content area.
//
function clearContent()
{
    var content = document.getElementById("content");

    if (content) {
        while (content.hasChildNodes()) {
            content.removeChild(content.firstChild);
        }
    }
}

//
// Function: setDateText(date)
// Show a date in the status area.
//
// date: Javascript Date to display
//
function setDateText(date)
{
    var dateText = document.getElementById("dateText");
    if (dateText) {
        if (date != null) {
            if (typeof(date) == "string") {
                dateText.innerText = date;
            }
            else {
                var dateStr = date.toLocaleDateString();
                dateText.innerText = dateStr;
            }
        }
        else {
            dateText.innerText = dashcode.getLocalizedString("Täglicher RSS-Feed");
        }
    }
}

//
// Function: setHTMLContent(title, description, date)
// Display an HTML item in the main content area.
//
// title: the item's title
// description: the item's description text
// date: the item's date
//
function setHTMLContent(title, description, date)
{
    var content = document.getElementById("content");
    if (content) {
        clearContent();

        if (title != null) {
            var titleDiv = document.createElement("div");
            titleDiv.setAttribute("id", "entryTitle");
            titleDiv.innerHTML = title;
            fixLinks(titleDiv);
            content.appendChild(titleDiv);
        }

        if (description != null) {
            var descDiv = document.createElement("div");
            descDiv.setAttribute("id", "entryDescription");
            descDiv.innerHTML = description;
            fixLinks(descDiv);
            content.appendChild(descDiv);
        }

        setDateText(date);
    }
}

//
// Function: setImageContent(title, image, date)
// Display an image item in the main content area.
// The image will be shrunk to fit, preserving its aspect ratio.
//
// title: the image's title
// image: Javascript Image object to display
// date: the image's date
//
function setImageContent(title, image, date)
{
    var content = document.getElementById("content");
    if (content) {
        clearContent();

        if (image != null) {
            var imgElement = document.createElement("img");
            imgElement.setAttribute("src", image.src);

            var boxStyle = document.defaultView.getComputedStyle(content, '');
            var boxHeight = parseInt(boxStyle.height);
            var boxWidth  = parseInt(boxStyle.width);
            var boxAspect = boxHeight / boxWidth;
            var imgAspect = image.height / image.width;

            var w = boxWidth;
            var h = boxHeight;
            var x = 0;
            var y = 0;

            if (imgAspect > boxAspect) {
                // Tall
                var ratio = boxHeight / image.height;
                w = Math.round(image.width * ratio);
                h = Math.round(image.height * ratio);
                x = Math.floor((boxWidth - w) / 2);
            }
            else if (imgAspect < boxAspect) {
                // Wide
                var ratio = boxWidth / image.width;
                w = Math.round(image.width * ratio);
                h = Math.round(image.height * ratio);
                y = Math.floor((boxHeight - h) / 2);
            }

            imgElement.setAttribute("width", w);
            imgElement.setAttribute("height", h);

            imgElement.style.width = w + "px";
            imgElement.style.height = h + "px";
            imgElement.style.marginTop = y + "px";
            imgElement.style.marginLeft = x + "px";

            content.appendChild(imgElement);
        }

        setDateText(date);
    }
}

//
// Function: fixLinks(htmlFragment)
// Update hyperlinks in a document fragment to use the openURL function.
//
// htmlFragment: DOM element in which to adjust links.
//
function fixLinks(htmlFragment)
{
    // Collect all the links
    var links = htmlFragment.getElementsByTagName("a");
    for (var i = 0; i < links.length; i++) {
        var aNode = links[i];
        // Send them to our clickOnLink function
        aNode.onclick = clickOnLink;
    }
}

//
// Function: parseISODate(dateToParse)
// Parse a date string in ISO 8601 format (YYYY-MM-DDTHH:MM:SS+OO:OO) into a Date object.
//
// dateToParse: String containing ISO 8601 date.
//
// Returns a Date object containing the parsed date.
//
function parseISODate(dateToParse)
{
    var returnDate = new Date();

    if (dateToParse && dateToParse.length > 1 && dateToParse.match(/^\d\d\d\d-\d\d-\d\d/)) {
        // separate date and time
        var dateTime = dateToParse.split("T");

        // set the date
        var dateArray = dateTime[0].split("-");
        if (dateArray[1]) {
            returnDate.setMonth(dateArray[1]-1);
        }
        if (dateArray[2]) {
            returnDate.setDate(dateArray[2]);
        }
        if (dateArray[0]) {
            returnDate.setYear(dateArray[0]);
        }

        // split time and offset
        var timeArray = null;
        if (dateTime[1]) {
            timeArray = dateTime[1].match(/(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:([+-])(\d\d):(\d\d))?/);
        }
        if (timeArray) {
            // set the time
            if (timeArray[1]) {
                returnDate.setHours(timeArray[1]);
            }
            if (timeArray[2]) {
                returnDate.setMinutes(timeArray[2]);
            }
            if (timeArray[3]) {
                returnDate.setSeconds(timeArray[3]);
            }

            // add the offset
            if (timeArray[4] && timeArray[5]) {
                var time = returnDate.getTime() - returnDate.getTimezoneOffset() * 60000;
                if (timeArray[4] == "+") {
                    time -= timeArray[5] * 3600000;
                }
                else {
                    time += timeArray[5] * 3600000;
                }
                returnDate.setTime(time);
            }
        }
    }

    return returnDate;
}

//
// Function: getFirstElementByTagName(node, tagName, namespace)
// Returns the first result of getElementsByTagName, or null if none.
//
// node: document node to search
// tagName: tag name to look for
// namespace: option namespace 
//
function getFirstElementByTagName(node, tagName, namespace) {
    var elements;

    if (!namespace) {
        elements = node.getElementsByTagName(tagName);
        if (!elements.length) {
            elements = node.getElementsByTagNameNS("*", tagName);
        }
    }
    else {
        elements = node.getElementsByTagNameNS(namespace, tagName);
    }

    if (elements.length) {
        return elements[0];
    }
    else {
        return null;
    }
}

//
// Function: getFirstImage(htmlData)
// Find the first image in a block of HTML
//
// htmlData: The block of HTML to search
//
function getFirstImage(htmlData)
{
    // Create a phony DIV to hold the HTML so we can use DOM methods on it
    var div = document.createElement("div");
    div.innerHTML = htmlData;

    var imgElement = getFirstElementByTagName(div, "img");
    if (imgElement) {
        var image = new Image();
        image.src = imgElement.src;

        return image;
    }
}

//
// Function: allData(node)
// Concatenate all the text data of a node's children.
//
// node: DOM element to search for text.
//
// Returns the concatenated text.
//
function allData(node)
{
    var data = "";
    node = node.firstChild;
    if (node) {
        if (node.data) {
            data += node.data;
        }
        while (node = node.nextSibling) {
            if (node.data) {
                data += node.data;
            }
        }
    }

    return data;
}

//
// Function: hideElement(elementId)
// Turn off display for the given element.
//
// elementId: DOM id of the element to hide.
//
function hideElement(elementId)
{
    var element = document.getElementById(elementId);
    if (element) {
        element.style.display = "none";
    }
}

//
// Function: showElement(elementId)
// Turn on display for the given element.
//
// elementId: DOM id of the element to show.
//
function showElement(elementId)
{
    var element = document.getElementById(elementId);
    if (element) {
        element.style.display = "block";
    }
}

//
// Function: setupHandlers()
// Set up Javascript mouseover handlers for the forward and back buttons.
//
function setupHandlers()
{
    var backOver = new Image();
    backOver.src = "Images/backButton_over.png";
    var backDown = new Image();
    backDown.src = "Images/backButton_down.png";
    var forwardOver = new Image();
    forwardOver.src = "Images/forwardButton_over.png";
    var forwardDown = new Image();
    forwardDown.src = "Images/forwardButton_down.png";

    var backButton = document.getElementById("backButton");
    if (backButton) {
        addHilightListeners(backButton, backOver, backDown);
    }

    var forwardButton = document.getElementById("forwardButton");
    if (forwardButton) {
        addHilightListeners(forwardButton, forwardOver, forwardDown);
    }
}

//
// Function: addHilightListeners(element, overImage, downImage)
// Used by setupHandlers() to add the necessary event handlers for each button.
//
// element: DOM element to add event listeners to
// overImage: mouseover image to show
// downImage: mousedown image to show
//
function addHilightListeners(element, overImage, downImage)
{
    var offImage = new Image();
    offImage.src = element.src;

    element.addEventListener("mouseover", function () { swapImage(element, overImage) }, true);
    element.addEventListener("mousedown", function () { swapImage(element, downImage) }, true);
    element.addEventListener("mouseup", function () { swapImage(element, overImage) }, true);
    element.addEventListener("mouseout", function () { swapImage(element, offImage) }, true);
}

//
// Function: swapImage(element, image)
// Show a new image in a DOM image element
//
// element: Image element to change
// image: Image to show
//
function swapImage(element, image)
{
    element.src = image.src;
}

//
// Function: clickOnLink()
// Called from onClick to open a link in the browser instead of in the widget.
//
function clickOnLink()
{
    if (window.widget) {
        widget.openURL(this.href);
        return false;
    }
}

//
// Function: showPrevEntry(event)
// Called by the back button to show the previous entry.
//
// event: onClick event from widget.
//
function showPrevEntry(event)
{
    if (entries && entries.length) {
        if (--currentEntry < 0) {
            currentEntry = 0;
        }

        showEntry(currentEntry);
    }
}

//
// Function: showNextEntry(event)
// Called by the forward button to show the next entry.
//
// event: onClick event from widget.
//
function showNextEntry(event)
{
    if (entries && entries.length && currentEntry < entries.length) {
        if (++currentEntry >= entries.length) {
            currentEntry = entries.length - 1;
        }

        showEntry(currentEntry);
    }
}

//
// Function: keyPressed(event)
// Handler to allow back and forward from the keyboard.
//
// event: onClick event from widget.
//
function keyPressed(event)
{
    switch (event.keyIdentifier) {
        case "Left":
            showPrevEntry();
            break;
        case "Right":
            showNextEntry();
            break;
        default:
            return;
    }

    event.stopPropagation();
    event.preventDefault();
}

//
// Function: load()
// Called by HTML body element's onload event when the widget is ready to start
//
function load()
{
    dashcode.setupParts();
    setupHandlers();
    hideElement("backButton");
    hideElement("forwardButton");
    document.addEventListener("keypress", keyPressed, true);

    entries = new Array();

    clearContent();
    refreshFeed();
}

//
// Function: remove()
// Called when the widget has been removed from the Dashboard
//
function remove()
{
    // Stop any timers to prevent CPU usage
    // Remove any preferences as needed
    // widget.setPreferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
}

//
// Function: hide()
// Called when the widget has been hidden
//
function hide()
{
    // Stop any timers to prevent CPU usage
}

//
// Function: show()
// Called when the widget has been shown
//
function show()
{
    // Refresh feed if 15 minutes have passed since the last update
    var now = (new Date).getTime();
    if ((now - lastUpdated) > 15 * 60 * 1000) {
        refreshFeed();
    }
}

//
// Function: sync()
// Called when the widget has been synchronized with .Mac
//
function sync()
{
    // Retrieve any preference values that you need to be synchronized here
    // Use this for an instance key's value:
    // instancePreferenceValue = widget.preferenceForKey(null, dashcode.createInstancePreferenceKey("your-key"));
    //
    // Or this for global key's value:
    // globalPreferenceValue = widget.preferenceForKey(null, "your-key");
}

//
// Function: showBack(event)
// Called when the info button is clicked to show the back of the widget
//
// event: onClick event from the info button
//
function showBack(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToBack");
    }

    front.style.display="none";
    back.style.display="block";

    if (window.widget) {
        setTimeout("widget.performTransition();", 0);
    }
}

//
// Function: showFront(event)
// Called when the done button is clicked from the back of the widget
//
// event: onClick event from the done button
//
function showFront(event)
{
    var front = document.getElementById("front");
    var back = document.getElementById("back");

    if (window.widget) {
        widget.prepareForTransition("ToFront");
    }

    front.style.display = "block";
    back.style.display = "none";

    if (window.widget) {
        setTimeout("widget.performTransition();", 0);
    }
}

// Initialize the Dashboard event handlers
if (window.widget) {
    widget.onremove = remove;
    widget.onhide = hide;
    widget.onshow = show;
    widget.onsync = sync;
}
