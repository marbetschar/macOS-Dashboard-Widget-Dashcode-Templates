/* 
 This file was generated by Dashcode.  
 You may edit this file to customize your widget or web page 
 according to the license.txt file included in the project.
 */

// The podcast feed, as obtained from attributes.js
var feed = attributes.podcastURL.replace(/^(itpc|pcast|feed):/i, "http:");

// How often the feed should refresh, from attributes.js
var refreshInterval = attributes.refreshInterval;

var lastUpdated = 0;                // Keeps track of the last update, so that the widget knows when to update
var xmlRequest = null;              // The current XMLHttpRequest
var loadingAnimationTimer = null;   // Tracks the "Loading..." animation
var trackStatusInterval = null;     // Tracks whether the episode is playing
var trackLoadingInterval = null;    // Tracks whether the episode is loading
var results = new Array;            // The saved, parsed results of the request, used to store the episodes
var podcastDescription = null;      // The podcast description, used on the widget's back
var isPlaying = false;              // Tracks whether the widget is currently playing
var firstRun = true;                // Tracks the widget's first run, for swaping a placeholder div and the movie
var currentEpisode = 0;             // Tracks the current episode number
var arrowOpacity = null;            // Tracks the opacity of the next/previous arrows

//
// Function: podcastLoad()
// Called when the widget loads.  Clears out placeholder text on the widget.
//
function podcastLoad()
{
    playButton.addEventListener("click", playpause, false);
    if (document.getElementById("episodeName")) {
        document.getElementById("episodeName").innerText = "";
    }
    if (document.getElementById("episodeDate")) {
        document.getElementById("episodeDate").innerText = "";
    }
    if (document.getElementById("episodeInformation")) {
        document.getElementById("episodeInformation").innerText = "";
    }
    if (document.getElementById("next")) {
        document.getElementById("next").style.display = "none";
    }
    if (document.getElementById("previous")) {
        document.getElementById("previous").style.display = "none";
    }

    var arrows = document.getElementById("arrows");
    arrowOpacity = parseFloat(document.defaultView.getComputedStyle(arrows, null).getPropertyValue("opacity"));
    arrows.style.opacity = 0.0;
}

//
// Function: podcastShow()
// Posts a request for the podcast RSS feed when the widget is shown.
// Requests are spaced out by the requestInterval to ease server load
// and prevent unnecessary load time.
//
function podcastShow()
{
    var episodeName = document.getElementById("episodeName");

    if (attributes.podcastURL == "") {
        if (episodeName) {
            episodeName.innerText = dashcode.getLocalizedString("Kein Podcast angegeben");
        }
    }
    else {
        var now = (new Date).getTime();

        // only check if referesh interval has passed
        if (((now - lastUpdated) > (refreshInterval * 60000)) && (!isPlaying)) {    // Interval in minutes; 60000 is one minute
            if (xmlRequest) {
                xmlRequest.abort();
                xmlRequest = null;
            }
            xmlRequest = new XMLHttpRequest();

            xmlRequest.onreadystatechange = function(e) {
                if (xmlRequest.readyState < 4) {
                    if (xmlRequest.responseText && xmlRequest.responseText.length > 10) {
                        if (!/<\?xml/i.test(xmlRequest.responseText)) {
                            // not going to be valid XML - kill it now
                            xmlRequest.abort();
                            noPodcastAvailable();
                        }
                    }
                }
                else {
                    if (xmlRequest.status == 200) {
                        processFeed(e, xmlRequest);
                    }
                    else {
                        noPodcastAvailable();
                    }
                }
            };

            xmlRequest.overrideMimeType("text/xml");
            xmlRequest.open("GET", feed);
            xmlRequest.setRequestHeader("Cache-Control", "no-cache");
            xmlRequest.send(null);

            if (episodeName) {
                startLoadingAnimation();    // Begins the "Loading..." animation
            }
        }
    }
}

//
// Function: noPodcastAvailable()
// Called when an XHR failed.
//
function noPodcastAvailable()
{
    xmlRequest = null;
    stopLoadingAnimation();
    var playButton = document.getElementById("playButton");
    playButton.src = "Images/reload.png";
    playButton.addEventListener("click", podcastReload, false);
    playButton.removeEventListener("click", playpause, false);
    if (episodeName) {
        episodeName.innerText = dashcode.getLocalizedString("Kein Podcast verfügbar");
    }
}

//
// Function: podcastReload()
// Called by the reload button to try again if the feed failed to load
//
function podcastReload()
{
    var playButton = document.getElementById("playButton");
    playButton.src = "Images/play.png";
    playButton.removeEventListener("click", podcastReload, false);
    playButton.addEventListener("click", playpause, false);
    podcastShow();
}

//
// Function: podcastHide()
// Pauses the video when Dashboard is hidden.
//
function podcastHide()
{
    if (isPlaying) {
        playpause();
    }
}

//
// Function: findChild(element, nodeName)
// Scans the children of a given DOM element for a node matching nodeName.
//
// element: The DOM element to search.
// nodeName: The node name to search for.
//
function findChild(element, nodeName)
{
    var child;

    for (child = element.firstChild; child != null; child = child.nextSibling) {
        if (child.nodeName == nodeName) {
            return child;
        }
    }

    return null;
}

//
// Function: processFeed(e, request)
// Extract the content of the podcast RSS feed and store the data in a
// results array.
//
// e: onLoad event from XMLHttpRequest
// request: xmlHttpRequest containing the feed
//
function processFeed (e, request)
{

    xmlRequest = null;
    if (request.responseXML) {
        // Clear the results array
        while (results.length > 0) {
            results.pop();
        }

        // Get the top level <rss> element
        var rss = findChild(request.responseXML, 'rss');
        if (!rss) return;

        // Get single subordinate channel element
        var channel = findChild(rss, 'channel');
        if (!channel) return;

        // Store the podcast description for use on the widget back
        podcastDescription = findChild(channel, 'description');
        if (!podcastDescription || !podcastDescription.firstChild) {
            podcastDescription = findChild(channel, 'itunes:summary');
            if (!podcastDescription || !podcastDescription.firstChild) {
                podcastDescription = dashcode.getLocalizedString("Keine Podcast-Beschreibung verfügbar");
            }
            else {
                podcastDescription = podcastDescription.firstChild.data;
            }
        }
        else {
            podcastDescription = podcastDescription.firstChild.data;
        }

        // Get all item elements subordinate to the channel element.
        // For each element, get title, pubDate, subtitle, description, and episode URL.
        for (var item = channel.firstChild; item != null; item = item.nextSibling) {
            if (item.nodeName == 'item') {
                var title = findChild (item, 'title');

                // we have to have the title to include the item in the list
                if (title) {
                    var title = findChild(item, 'title');
                    if (!title || !title.firstChild) {
                        title = dashcode.getLocalizedString("Kein Folgentitel verfügbar");
                    }
                    else {
                        title = title.firstChild.data;
                    }

                    var date = findChild(item, 'pubDate');
                    var dateString = null;
                    if (!date || !date.firstChild) {
                        dateString = null;
                        date = null;
                    }
                    else {
                        dateString = date.firstChild.data;
                        date = new Date(Date.parse(date.firstChild.data));
                    }

                    var description = findChild(item, 'description');
                    if (!description || !description.firstChild) {
                        description = dashcode.getLocalizedString("Keine Folgenbeschreibung verfügbar");
                    }
                    else {
                        description = description.firstChild.data;
                    }

                    var subtitle = findChild(item, 'itunes:subtitle');
                    if (!subtitle || !subtitle.firstChild) {
                        subtitle = description;
                    }
                    else {
                        subtitle = subtitle.firstChild.data;
                    }

                    var link = findChild(item, 'link');
                    if (!link) {
                        link = null;
                    }
                    else {
                        link = link.firstChild.data;
                    }

                    var enclosure = findChild(item, 'enclosure');
                    if (!enclosure) {
                        // if there's no enclosure, there's no episode to play; ignore the entry and move on.
                        continue;
                    }
                    else {
                        enclosure = enclosure.getAttribute('url');
                    }

                    results[results.length] = {
                        title:title,
                        date:date,
                        dateString:dateString,
                        subtitle:subtitle,
                        description:description,
                        link:link,
                        track:enclosure
                    };
                }
            }
        }

        // Sort by date
        results.sort(function (a, b) { 
            return b.date - a.date; 
        });

        // Since we have results, pause the loading animation
        stopLoadingAnimation();

        currentEpisode = 0;
        updateEpisode(results[currentEpisode]);

        // Reset the last updated value track how often the widget refreshes
        lastUpdated = (new Date).getTime();
    }
}

//
// Function: createDateStr(date)
// Creates a readable date string from the provided Date object.
//
// date: JavaScript Date object to format
//
function createDateStr(date)
{
    if (!date) {
        return dashcode.getLocalizedString("Datum ungültig oder nicht verfügbar");
    }

    var day;
    switch (date.getDay()) {
        case 0: day = dashcode.getLocalizedString("Sonntag"); break;
        case 1: day = dashcode.getLocalizedString("Montag"); break;
        case 2: day = dashcode.getLocalizedString("Dienstag"); break;
        case 3: day = dashcode.getLocalizedString("Mittwoch"); break;
        case 4: day = dashcode.getLocalizedString("Donnerstag"); break;
        case 5: day = dashcode.getLocalizedString("Freitag"); break;
        case 6: day = dashcode.getLocalizedString("Samstag"); break;
        default: day = "";
    }

    var month;
    switch (date.getMonth()) {
        case 0: month = dashcode.getLocalizedString("Januar"); break;
        case 1: month = dashcode.getLocalizedString("Februar"); break;
        case 2: month = dashcode.getLocalizedString("März"); break;
        case 3: month = dashcode.getLocalizedString("April"); break;
        case 4: month = dashcode.getLocalizedString("Mai"); break;
        case 5: month = dashcode.getLocalizedString("Juni"); break;
        case 6: month = dashcode.getLocalizedString("Juli"); break;
        case 7: month = dashcode.getLocalizedString("August"); break;
        case 8: month = dashcode.getLocalizedString("September"); break;
        case 9: month = dashcode.getLocalizedString("Oktober"); break;
        case 10: month = dashcode.getLocalizedString("November"); break;
        case 11: month = dashcode.getLocalizedString("Dezember"); break;
        default: month = "";
    }

    if (day == "" && month == "") {
        return null;
    }
    else {
        return day + ", " + month + " " + date.getDate() + ", " + date.getFullYear();
    }
}

//
// Function: changeEpisode(which)
// Called when a new item is selected in the menu; swaps out the
// episode info and track with the selected episode's.
//
// which: whether to go forward or backward
//
function changeEpisode(which)
{
    if (which == "next") {
        updateEpisode(results[--currentEpisode]);
    }
    if (which == "previous") {
        updateEpisode(results[++currentEpisode]);
    }
}

//
// Function: updateEpisode(elem)
// Updates all of the various strings on the widget with the supplied
// episode's information.  Also preps the episode track to play and
// pauses it
//
// elem: chosen episode from results array
//
function updateEpisode(elem)
{
    if (isPlaying) {
        playpause();
    }

    if (document.getElementById("episodeName")) {
        document.getElementById("episodeName").innerText = stripTags(elem.title); 
    }

    var episodeDate = document.getElementById("episodeDate");
    var date = createDateStr(elem.date);
    if (!date) {
        if (elem.dateString) {
            if (episodeDate) {
                episodeDate.innerText = elem.dateString;
            }
        }
    }
    else {
        if (episodeDate) {
            episodeDate.innerText = date;
        }
    }

    if (document.getElementById("episodeDescription")) {
        document.getElementById("episodeDescription").innerText = stripTags(elem.subtitle);
    }

    var episodeInformation = document.getElementById("episodeInformation");
    if (episodeInformation) {
        episodeInformation.innerHTML = (elem.title + "<br>" + elem.description + "<br><br>" + dashcode.getLocalizedString("Über diesen Podcast:") + "<br>" +  podcastDescription).replace(/\r?\n/g , "<br>");

        // Remove any embedded videos
        var embeddedElements = episodeInformation.getElementsByTagName("embed");
        for (var i = 0; i < embeddedElements.length; i++) {
            (embeddedElements[i].parentNode).removeChild(embeddedElements[i]);
        }

        // Remove any videos embedded using the object tag
        embeddedElements = episodeInformation.getElementsByTagName("object");
        for (var i = 0; i < embeddedElements.length; i++) {
            (embeddedElements[i].parentNode).removeChild(embeddedElements[i]);
        }

        // Change all links into onclick calls, so that the link opens in a browser
        var anchors = episodeInformation.getElementsByTagName("a");
        for (i = 0; i < anchors.length; i++) {
            anchors[i].setAttribute("onclick","widget.openURL('" + (anchors[i].href).replace(/([\\\'])/g, '\\$1') + "');");  //"
            anchors[i].removeAttribute("href");
        }
    }

    // Load the podcast's track
    var episodeTrack = document.getElementById("episodeTrack");
    if (!firstRun) {
        episodeTrack.SetResetPropertiesOnReload(false);
        episodeTrack.SetURL(elem.track);
    }
    else {
        var episode = document.createElement("embed");
        episode.setAttribute("id", "episodeTrack");
        episode.setAttribute("controller", "false");
        episode.setAttribute("autoplay", "false");
        episode.setAttribute("enablejavascript", "true");
        episode.setAttribute("type", "video/quicktime");
        episode.setAttribute("scale", "aspect");
        episode.setAttribute("src", elem.track);
        episode.setAttribute("showlogo", "false");
        document.getElementById("front").removeChild(document.getElementById("episodeTrack"));
        document.getElementById("body").appendChild(episode);
        firstRun = !firstRun;
    }

    // if the newest episode is currently shown, hide the next arrow
    if (currentEpisode == 0) {
        document.getElementById("next").style.display = "none";
    }
    else {
        document.getElementById("next").style.display = "block";
    }

    // if the oldest episode is currently shown, hide the previous arrow
    if (currentEpisode == (results.length - 1)) {
        document.getElementById("previous").style.display = "none";
    }
    else {
        document.getElementById("previous").style.display = "block";
    }

    // Load a spinner, so that people know the video is loading
    if (!(document.getElementById("_spinner"))) {
        document.getElementById("playButton").src = "Images/loading.png";
        var spinner = document.createElement("img");
        spinner.setAttribute("id","_spinner");
        spinner.setAttribute("src","Images/progress.gif");
        var playPauseStyle = document.defaultView.getComputedStyle(document.getElementById("playButton"), null);
        spinner.setAttribute("style", "position: absolute; width:" + playPauseStyle.getPropertyValue("width") +
                                    "; height:" + playPauseStyle.getPropertyValue("height") +
                                    "; bottom:" + playPauseStyle.getPropertyValue("bottom") +
                                    "; left:" + playPauseStyle.getPropertyValue("left") +
                                    "; z-index:8000;");
        document.getElementById("front").appendChild(spinner);
    }

    // Check in to see if things have loaded
    var checkTrackLoad = function ()
    {
        var track = document.getElementById("episodeTrack");
        var status = track.GetPluginStatus();
        if ((status.match("Playable")) || (status.match("Complete"))) {
            if (document.getElementById("_spinner")) {
                document.getElementById("front").removeChild(document.getElementById("_spinner"));
            }
            document.getElementById("playButton").src = "Images/play.png";
            clearInterval(trackLoadingInterval);
        }
        else {
            if ((status.match("Error"))) {
                if (document.getElementById("_spinner")) {
                    document.getElementById("front").removeChild(document.getElementById("_spinner"));
                }
                document.getElementById("playButton").src = "Images/error.png";
                clearInterval(trackLoadingInterval);
            }
        }
    };
    if (trackLoadingInterval) {
        clearInterval(trackLoadingInterval);
    }
    trackLoadingInterval = setInterval(checkTrackLoad, 1000);
}

//
// Function: stripTags(aString)
// Removes any extra HTML tags that may be strewn about the response XML.
//
// aString: string to strip the tags from
//
function stripTags(aString)
{
    return aString.replace(/<[^>]*>/g,"");
}

//
// Function: subscribe(event)
// Called when the subscribe button is clicked on the widget's back;
// hands off the podcast URL to iTunes.
//
// event: onClick event from the button
//
function subscribe(event)
{
    widget.openURL(feed.replace(/^http:/, "itpc:"));
}

//
// Function: startLoadingAnimation()
// Places animated "Loading..." text on the widget while the feed loads.
//
function startLoadingAnimation()
{
    var dots = 0;
    var animateLoadingDots = function ()
    {
        var loading = dashcode.getLocalizedString("Laden");
        for (var i = 0; i < dots; i++) {
            loading = loading + ".";
        }
        document.getElementById("episodeName").innerText = loading;

        if (++dots > 3) {
            dots = 0;
        }
    };
    loadingAnimationTimer = setInterval(animateLoadingDots, 500);
}

//
// Function: stopLoadingAnimation()
//
// Stops the "Loading..." animation when the feed finishes loading.
//
function stopLoadingAnimation()
{
    if (loadingAnimationTimer != null) {
        clearInterval(loadingAnimationTimer);
        loadingAnimationTimer = null;
    }
}

//
// Function: playpause(event)
// Toggles whether the widget is playing or not
//
// event: onClick event from the button.
//
function playpause(event)
{
    if (firstRun) return;

    var track = document.getElementById("episodeTrack");
    if (!track) return;

    var status = track.GetPluginStatus();
    if ((status.match("Waiting")) || (status.match("Loading")) || (status.match("Error"))) return;

    if (!isPlaying) {
        document.getElementById("playButton").src = "Images/pause.png";
        track.Play();
        var checkTrackStatus = function ()
        {
            var track = document.getElementById("episodeTrack");
            if (track.GetTime() >= track.GetDuration()) {
                playpause();
            }
        };
        trackStatusInterval = setInterval(checkTrackStatus,1000);
    }
    else {
        document.getElementById("playButton").src = "Images/play.png";
        track.Stop();
        if (track.GetTime() >= track.GetDuration()) {
            // If done, set to beginning
            track.SetTime(0);
        }
        clearInterval(trackStatusInterval);
    }
    isPlaying = !isPlaying;
}

//
// Function: hideMovie()
// Sets the movie's visibility to hidden when the widget's back is
// shown. Without this, the movie appears on the back as well as the
// front.
//
function hideMovie()
{
    var track = document.getElementById("episodeTrack");
    if(track) {
        track.style.visibility = "hidden";
        if(isPlaying) { track.Stop(); }
    }
}

//
// Function: showMovie()
// Sets the movie to visible again when the front is shown.
//
function showMovie()
{
    var track = document.getElementById("episodeTrack");
    if(track) {
        track.style.visibility = "visible";
        if(isPlaying) { track.Play(); }
    }
}

//
// frontMove() frontOutDelay() frontOut() animationComplete & fadeArrows()
// These functions handle the fade in and out for the next/previous
// that happen when the mouse enters and leaves the bounds of the
// widget.
//
var outdelay = null;
var labelshown = null;
var animation = null;
var animator = null;

function frontMove(event)
{
    if (outdelay !== null) {
        clearTimeout(outdelay);
        outdelay = null
    }
    if (labelshown) return;

    var from = 0.0;
    var duration = 500;
    if (animation != null) {
        from = animation.now;
        duration = (new Date).getTime() - animator.startTime;
        animator.stop();
    }

    labelshown = true;

    var l_animator = new AppleAnimator(duration, 13);
    l_animator.oncomplete = animationComplete;
    animator = l_animator;

    animation = new AppleAnimation(from, arrowOpacity, fadeArrows);
    l_animator.addAnimation(animation);
    l_animator.start();
}

function frontOutDelay(event)
{
    if (outdelay === null) {
        outdelay = setTimeout(frontOut, 0);
    }
}

function frontOut()
{
    if (outdelay !== undefined) {
        clearTimeout(outdelay);
        outdelay = null;
    }
    if (!labelshown) return;

    var from = arrowOpacity;
    var duration = 500;
    if (animation != null) {
        from = animation.now;
        duration = (new Date).getTime() - animator.startTime;
        animator.stop();
    }

    var l_animator = new AppleAnimator(duration, 13);
    l_animator.oncomplete = animationComplete;
    animator = l_animator;

    animation = new AppleAnimation(from, 0.0, fadeArrows);
    l_animator.addAnimation(animation);
    l_animator.start();

    labelshown = false;
}

function animationComplete()
{
    animation = null;
    animator = null;
}

function fadeArrows(animation, current, start, finish)
{
    if (document.getElementById("arrows")) {
        document.getElementById("arrows").style.opacity = current;
    }
}
